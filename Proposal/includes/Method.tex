%\addcontentsline{toc}{section}{Method}

%A description of the procedure.
% This can include:
% - a description of the theoretical or conceptual framework
% - sources of evidence and authority
% - analytical technique and research design
% - a timetable for completing the study.



\section{Methodology}

\subsection{Objectives}

The objective of this project is to be able to create wire frame models of the interior of buildings.

Point clouds are notoriously difficult to navigate on computers, especially the interior of buildings. creating a wire frame model makes the buildings interior easier to navigate, measure and use in a practical way.

The goal of surface reconstruction can be said as follows: Given a set of sample points P assumed to lie on or near an unknown surface S, create a surface model S' approximating S
A surface reconstruction procedure cannot guarantee the recovering of the surface exactly, since we have information about the surface only through a finite set of points.

Using C++ and Point Cloud Library (PCL) an algorithm to complete these tasks with as little intervention as possible will be written as an add on function onto existing software.

For this to take place all outputted data must be in recognised file formats.


\subsection{Questions}
\begin{itemize}

\item How do we go about segmenting the point cloud?

\item What is the best way to find breaklines? (edges)

\item How do we decide which point belongs to which room in the case of multiple rooms?

\item generalising, removing points? adding points if necessary?

\item Triangulation, use all points? or minimize number of lines in the render?

\item RANSAC?

\end{itemize}


\subsection{Proposed methods}


From points to surface:
%section 4.2 from FROM POINT CLOUD TO SURFACE: THE MODELING AND VISUALIZATION PROBLEM

\begin{enumerate}
\item Pre-Processing - Removing noise, cleaning up data to allow work to be done on it, or sampling to reduce computation time.

\item Determination of the global topology of the objects surface - look for segments and make sure features such as breadlines and such are preserved
	
\item generation of the polygonal surface - triangular meshes are created satisfying certain requirements e.g. size limits ect \ldots

\item post processing - when the model is created, editing operations are commonly applied to refine and perfect the polygonal surface
\end{enumerate}

\subsection{Other Considerations}

In some cases there may be an shortage of points or in the more likely case there are to many points. for example a wall, we don't need 100 000 points to approximate a wall, so we can generalize that segment to make computations easier and faster.

But equally we may get a terrible approximation if we are missing large portions of the wall due to scan shadows we may get a really bad approximation of the wall in places so adding points may become necessary.




















%Not PCA to make planes -- wire frames
%
%The method looked at is a PCA analysis of a point cloud.
%The whole process will be created in C++ and Point Cloud Library(PCA) will be used.\\
%
%When segmenting a point cloud using this method you select a point in a point cloud and calculate that points principal components
%
%The principal components of a set of vectors that point along the line of most variance in data.
%
%Every set of data has a number of eigenvalues and eigenvectors equal to the dimensions of the data. so in order for us to find eigenvectors and eigenvalues for a specific point we look at the neighbourhood around that point grab points in a sphere around the point and make that the data set.
%
%An eigenvector is a direction and an eigenvalue that corresponds to that eigenvector. The eigenvalue tells you how much variance there is along that specific vector. when creating eigenvectors they will always point along the direction that has the greatest variance and all vectors sill be orthogonal to each other. 
%
%These properties are used for the PCA, by knowing that the eigenvector with the smallest associated value is usually a good estimate of the normal vector.
%
%We then fix the value of the normal, that we calculated with the PCA, and make sure that it is correct by looking at the direction from the point to the scanner.
%
%Once we have normals for each point we can easily classify points that are close together into segments with normals pointing in the same direction. then the segments are classified into classes such as walls, $ wall\_X $ and $ wall\_Y $ ect, $ ceiling $, pointing along $ -Z $, and $ floor $, pointing along $ +Z $, based on which direction their normals are pointing. All other points who's normals are significantly different to the $ X,Y,Z $ axes are then classed as $ remaining $.
%
%Then using classification of each point a random point is chosen, it then check the nearest points around it and grows the region until the segment is created. then the process is repeted until the whole image is segmented.
%
%after that planes are fitted to each segment.

